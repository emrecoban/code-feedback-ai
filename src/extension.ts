import * as vscode from "vscode";

// AI Provider enum - defines which AI services are supported
enum AIProvider {
  OPENAI = "openai",
  GEMINI = "gemini",
  CLAUDE = "claude",
}

// Dil sistemi i√ßin translation interface'i - ƒ∞ngilizce key'ler ile
interface Translations {
  cursor_analysis: {
    function: string;
    conditional: string;
    loop: string;
    comment: string;
    long_line: string;
    empty_line: string;
    generic: string;
  };
  newline_messages: {
    single: string;
    multiple: string;
  };
  errors: {
    api_key_required: string;
    invalid_api_key: string;
    rate_limit_reached: string;
    quota_exceeded: string;
    connection_issue: string;
    service_unavailable: string;
    ai_unavailable: string;
    too_many_errors: string;
    api_key_configuration_needed: string;
    provider_not_selected: string;
    provider_config_missing: string;
  };
  notifications: {
    api_key_setup_title: string;
    api_key_setup_message: string;
    too_many_errors_warning: string;
    rate_limit_warning: string;
    quota_exceeded_error: string;
    network_warning: string;
    service_unavailable_warning: string;
    ai_re_enabled: string;
    rate_limit_passed: string;
    provider_changed: string;
  };
  actions: {
    open_settings: string;
    get_api_key: string;
    disable_ai: string;
    check_billing: string;
    learn_more: string;
    get_openai_key: string;
    get_gemini_key: string;
    get_claude_key: string;
  };
  ui: {
    panel_title: string;
    ai_analysis_prefix: string;
    ai_review_prefix: string;
  };
  providers: {
    openai: string;
    gemini: string;
    claude: string;
  };
}

// AI API response interfaces
interface OpenAIResponse {
  choices: Array<{
    message: {
      content: string;
    };
  }>;
  usage: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}

interface GeminiResponse {
  candidates: Array<{
    content: {
      parts: Array<{
        text: string;
      }>;
    };
  }>;
  usageMetadata: {
    promptTokenCount: number;
    candidatesTokenCount: number;
    totalTokenCount: number;
  };
}

interface ClaudeResponse {
  content: Array<{
    text: string;
  }>;
  usage: {
    input_tokens: number;
    output_tokens: number;
  };
}

// T√ºm dillerin √ßevirileri - ƒ∞ngilizce key'ler ile organize edildi
const translations: Record<string, Translations> = {
  english: {
    cursor_analysis: {
      function:
        "Cursor paused for analysis. Current context: Function definition - Consider: Does this function have a single responsibility?",
      conditional:
        "Cursor paused for analysis. Current context: Conditional logic - Consider: Can this condition be simplified or extracted to a variable?",
      loop: "Cursor paused for analysis. Current context: Loop logic - Consider: Is this loop complexity necessary? Could it be refactored?",
      comment:
        "Cursor paused for analysis. Current context: Comment - Good practice! Comments help explain the 'why', not just the 'what'.",
      long_line:
        "Cursor paused for analysis. Current context: Long line ({length} characters) - Consider breaking it into multiple lines for better readability.",
      empty_line:
        "Cursor paused for analysis. Current context: Empty line - White space can improve code readability when used purposefully.",
      generic: "Cursor paused for analysis. Current context: {context}",
    },
    newline_messages: {
      single: "‚ú® New line added - great structure!",
      multiple: "‚ú® {count} new lines added - good code organization!",
    },
    errors: {
      api_key_required: "API key required for AI analysis",
      invalid_api_key: "Invalid API key - Please check settings",
      rate_limit_reached: "Rate limit reached - Will retry automatically",
      quota_exceeded: "API quota exceeded - Check billing",
      connection_issue: "Connection issue - Retrying...",
      service_unavailable: "AI service unavailable - Retrying...",
      ai_unavailable: "AI temporarily unavailable",
      too_many_errors:
        "AI features paused due to repeated errors. Will retry automatically in 10 minutes.",
      api_key_configuration_needed:
        "API key required - Please configure your AI provider API key in settings to enable AI feedback",
      provider_not_selected:
        "No AI provider selected - Please choose a provider in settings",
      provider_config_missing:
        "Selected AI provider is not properly configured",
    },
    notifications: {
      api_key_setup_title:
        "ü§ñ AI Code Feedback: AI provider API key required for AI features.",
      api_key_setup_message:
        "ü§ñ AI Code Feedback: AI provider API key required for AI features.",
      too_many_errors_warning:
        "‚ö†Ô∏è AI Code Feedback: Too many consecutive errors. AI features temporarily disabled for 10 minutes.",
      rate_limit_warning:
        "‚è±Ô∏è AI Code Feedback: Rate limit reached. AI features will resume in approximately {minutes} minute(s).",
      quota_exceeded_error:
        "üí≥ AI Code Feedback: AI API quota exceeded. Please check your billing.",
      network_warning:
        "üåê AI Code Feedback: Network connection issue. Will retry automatically.",
      service_unavailable_warning:
        "üîß AI Code Feedback: AI service temporarily unavailable. Will retry automatically.",
      ai_re_enabled: "‚úÖ AI Code Feedback: AI analysis has been re-enabled.",
      rate_limit_passed:
        "‚úÖ AI Code Feedback: Rate limit period has passed. AI analysis is now available again.",
      provider_changed:
        "üîÑ AI Provider changed to {provider}. AI features ready!",
    },
    actions: {
      open_settings: "Open Settings",
      get_api_key: "Get API Key",
      disable_ai: "Disable AI Features",
      check_billing: "Check Billing",
      learn_more: "Learn More",
      get_openai_key: "Get OpenAI Key",
      get_gemini_key: "Get Gemini Key",
      get_claude_key: "Get Claude Key",
    },
    ui: {
      panel_title: "ü§ñ AI Code Feedback",
      ai_analysis_prefix: "üéØ",
      ai_review_prefix: "üîç AI Code Review:",
    },
    providers: {
      openai: "OpenAI",
      gemini: "Google Gemini",
      claude: "Anthropic Claude",
    },
  },
  espanol: {
    cursor_analysis: {
      function:
        "Cursor pausado para an√°lisis. Contexto actual: Definici√≥n de funci√≥n - Considera: ¬øEsta funci√≥n tiene una sola responsabilidad?",
      conditional:
        "Cursor pausado para an√°lisis. Contexto actual: L√≥gica condicional - Considera: ¬øSe puede simplificar esta condici√≥n o extraer a una variable?",
      loop: "Cursor pausado para an√°lisis. Contexto actual: L√≥gica de bucle - Considera: ¬øEs necesaria esta complejidad del bucle? ¬øSe puede refactorizar?",
      comment:
        "Cursor pausado para an√°lisis. Contexto actual: Comentario - ¬°Buena pr√°ctica! Los comentarios ayudan a explicar el 'por qu√©', no solo el 'qu√©'.",
      long_line:
        "Cursor pausado para an√°lisis. Contexto actual: L√≠nea larga ({length} caracteres) - Considera dividirla en m√∫ltiples l√≠neas para mejor legibilidad.",
      empty_line:
        "Cursor pausado para an√°lisis. Contexto actual: L√≠nea vac√≠a - Los espacios en blanco pueden mejorar la legibilidad cuando se usan con prop√≥sito.",
      generic: "Cursor pausado para an√°lisis. Contexto actual: {context}",
    },
    newline_messages: {
      single: "‚ú® Nueva l√≠nea a√±adida - ¬°excelente estructura!",
      multiple:
        "‚ú® {count} nuevas l√≠neas a√±adidas - ¬°buena organizaci√≥n del c√≥digo!",
    },
    errors: {
      api_key_required: "Clave API requerida para an√°lisis IA",
      invalid_api_key: "Clave API inv√°lida - Por favor revisa la configuraci√≥n",
      rate_limit_reached:
        "L√≠mite de velocidad alcanzado - Se reintentar√° autom√°ticamente",
      quota_exceeded: "Cuota de API excedida - Revisa la facturaci√≥n",
      connection_issue: "Problema de conexi√≥n - Reintentando...",
      service_unavailable: "Servicio IA no disponible - Reintentando...",
      ai_unavailable: "IA temporalmente no disponible",
      too_many_errors:
        "Funciones IA pausadas debido a errores repetidos. Se reintentar√° autom√°ticamente en 10 minutos.",
      api_key_configuration_needed:
        "Clave API requerida - Por favor configura tu clave API del proveedor IA en los ajustes para habilitar el feedback IA",
      provider_not_selected:
        "Ning√∫n proveedor IA seleccionado - Por favor elige un proveedor en los ajustes",
      provider_config_missing:
        "El proveedor IA seleccionado no est√° configurado correctamente",
    },
    notifications: {
      api_key_setup_title:
        "ü§ñ AI Code Feedback: Clave API del proveedor IA requerida para funciones IA.",
      api_key_setup_message:
        "ü§ñ AI Code Feedback: Clave API del proveedor IA requerida para funciones IA.",
      too_many_errors_warning:
        "‚ö†Ô∏è AI Code Feedback: Demasiados errores consecutivos. Funciones IA deshabilitadas temporalmente por 10 minutos.",
      rate_limit_warning:
        "‚è±Ô∏è AI Code Feedback: L√≠mite de velocidad alcanzado. Las funciones IA se reanudar√°n en aproximadamente {minutes} minuto(s).",
      quota_exceeded_error:
        "üí≥ AI Code Feedback: Cuota de API IA excedida. Por favor revisa tu facturaci√≥n.",
      network_warning:
        "üåê AI Code Feedback: Problema de conexi√≥n de red. Se reintentar√° autom√°ticamente.",
      service_unavailable_warning:
        "üîß AI Code Feedback: Servicio IA temporalmente no disponible. Se reintentar√° autom√°ticamente.",
      ai_re_enabled:
        "‚úÖ AI Code Feedback: El an√°lisis IA ha sido rehabilitado.",
      rate_limit_passed:
        "‚úÖ AI Code Feedback: El per√≠odo de l√≠mite de velocidad ha pasado. El an√°lisis IA est√° disponible nuevamente.",
      provider_changed:
        "üîÑ Proveedor IA cambiado a {provider}. ¬°Funciones IA listas!",
    },
    actions: {
      open_settings: "Abrir Ajustes",
      get_api_key: "Obtener Clave API",
      disable_ai: "Deshabilitar Funciones IA",
      check_billing: "Revisar Facturaci√≥n",
      learn_more: "Aprender M√°s",
      get_openai_key: "Obtener Clave OpenAI",
      get_gemini_key: "Obtener Clave Gemini",
      get_claude_key: "Obtener Clave Claude",
    },
    ui: {
      panel_title: "ü§ñ Feedback IA de C√≥digo",
      ai_analysis_prefix: "üéØ",
      ai_review_prefix: "üîç Revisi√≥n IA del C√≥digo:",
    },
    providers: {
      openai: "OpenAI",
      gemini: "Google Gemini",
      claude: "Anthropic Claude",
    },
  },
  turkce: {
    cursor_analysis: {
      function:
        "ƒ∞mle√ß analiz i√ßin durdu. Mevcut baƒülam: Fonksiyon tanƒ±mƒ± - D√º≈ü√ºn: Bu fonksiyonun tek bir sorumluluƒüu var mƒ±?",
      conditional:
        "ƒ∞mle√ß analiz i√ßin durdu. Mevcut baƒülam: Ko≈üullu mantƒ±k - D√º≈ü√ºn: Bu ko≈üul basitle≈ütirilebilir mi veya bir deƒüi≈ükene √ßƒ±karƒ±labilir mi?",
      loop: "ƒ∞mle√ß analiz i√ßin durdu. Mevcut baƒülam: D√∂ng√º mantƒ±ƒüƒ± - D√º≈ü√ºn: Bu d√∂ng√º karma≈üƒ±klƒ±ƒüƒ± gerekli mi? Yeniden d√ºzenlenebilir mi?",
      comment:
        "ƒ∞mle√ß analiz i√ßin durdu. Mevcut baƒülam: Yorum - ƒ∞yi uygulama! Yorumlar sadece 'ne'yi deƒüil, 'neden'i a√ßƒ±klamaya yardƒ±mcƒ± olur.",
      long_line:
        "ƒ∞mle√ß analiz i√ßin durdu. Mevcut baƒülam: Uzun satƒ±r ({length} karakter) - Daha iyi okunabilirlik i√ßin birden fazla satƒ±ra b√∂lmeyi d√º≈ü√ºn.",
      empty_line:
        "ƒ∞mle√ß analiz i√ßin durdu. Mevcut baƒülam: Bo≈ü satƒ±r - Beyaz alan, ama√ßlƒ± kullanƒ±ldƒ±ƒüƒ±nda kod okunabilirliƒüini artƒ±rabilir.",
      generic: "ƒ∞mle√ß analiz i√ßin durdu. Mevcut baƒülam: {context}",
    },
    newline_messages: {
      single: "‚ú® Yeni satƒ±r eklendi - harika yapƒ±!",
      multiple: "‚ú® {count} yeni satƒ±r eklendi - iyi kod organizasyonu!",
    },
    errors: {
      api_key_required: "AI analizi i√ßin API anahtarƒ± gerekli",
      invalid_api_key: "Ge√ßersiz API anahtarƒ± - L√ºtfen ayarlarƒ± kontrol edin",
      rate_limit_reached:
        "Hƒ±z sƒ±nƒ±rƒ±na ula≈üƒ±ldƒ± - Otomatik olarak yeniden denenecek",
      quota_exceeded: "API kotasƒ± a≈üƒ±ldƒ± - Faturalandƒ±rmayƒ± kontrol edin",
      connection_issue: "Baƒülantƒ± sorunu - Yeniden deneniyor...",
      service_unavailable: "AI servisi kullanƒ±lamƒ±yor - Yeniden deneniyor...",
      ai_unavailable: "AI ge√ßici olarak kullanƒ±lamƒ±yor",
      too_many_errors:
        "Tekrarlanan hatalar nedeniyle AI √∂zellikleri duraklatƒ±ldƒ±. 10 dakika i√ßinde otomatik olarak yeniden denenecek.",
      api_key_configuration_needed:
        "API anahtarƒ± gerekli - AI geri bildirimini etkinle≈ütirmek i√ßin l√ºtfen AI saƒülayƒ±cƒ± API anahtarƒ±nƒ±zƒ± ayarlarda yapƒ±landƒ±rƒ±n",
      provider_not_selected:
        "Hi√ßbir AI saƒülayƒ±cƒ± se√ßilmedi - L√ºtfen ayarlarda bir saƒülayƒ±cƒ± se√ßin",
      provider_config_missing: "Se√ßilen AI saƒülayƒ±cƒ± d√ºzg√ºn yapƒ±landƒ±rƒ±lmamƒ±≈ü",
    },
    notifications: {
      api_key_setup_title:
        "ü§ñ AI Code Feedback: AI √∂zellikleri i√ßin AI saƒülayƒ±cƒ± API anahtarƒ± gerekli.",
      api_key_setup_message:
        "ü§ñ AI Code Feedback: AI √∂zellikleri i√ßin AI saƒülayƒ±cƒ± API anahtarƒ± gerekli.",
      too_many_errors_warning:
        "‚ö†Ô∏è AI Code Feedback: √áok fazla ardƒ±≈üƒ±k hata. AI √∂zellikleri 10 dakika ge√ßici olarak devre dƒ±≈üƒ± bƒ±rakƒ±ldƒ±.",
      rate_limit_warning:
        "‚è±Ô∏è AI Code Feedback: Hƒ±z sƒ±nƒ±rƒ±na ula≈üƒ±ldƒ±. AI √∂zellikleri yakla≈üƒ±k {minutes} dakika i√ßinde devam edecek.",
      quota_exceeded_error:
        "üí≥ AI Code Feedback: AI API kotasƒ± a≈üƒ±ldƒ±. L√ºtfen faturalandƒ±rmanƒ±zƒ± kontrol edin.",
      network_warning:
        "üåê AI Code Feedback: Aƒü baƒülantƒ±sƒ± sorunu. Otomatik olarak yeniden denenecek.",
      service_unavailable_warning:
        "üîß AI Code Feedback: AI servisi ge√ßici olarak kullanƒ±lamƒ±yor. Otomatik olarak yeniden denenecek.",
      ai_re_enabled: "‚úÖ AI Code Feedback: AI analizi yeniden etkinle≈ütirildi.",
      rate_limit_passed:
        "‚úÖ AI Code Feedback: Hƒ±z sƒ±nƒ±rƒ± s√ºresi ge√ßti. AI analizi ≈üimdi tekrar kullanƒ±labilir.",
      provider_changed:
        "üîÑ AI Saƒülayƒ±cƒ± {provider} olarak deƒüi≈ütirildi. AI √∂zellikleri hazƒ±r!",
    },
    actions: {
      open_settings: "Ayarlarƒ± A√ß",
      get_api_key: "API Anahtarƒ± Al",
      disable_ai: "AI √ñzelliklerini Devre Dƒ±≈üƒ± Bƒ±rak",
      check_billing: "Faturalandƒ±rmayƒ± Kontrol Et",
      learn_more: "Daha Fazla √ñƒüren",
      get_openai_key: "OpenAI Anahtarƒ± Al",
      get_gemini_key: "Gemini Anahtarƒ± Al",
      get_claude_key: "Claude Anahtarƒ± Al",
    },
    ui: {
      panel_title: "ü§ñ AI Kod Geri Bildirimi",
      ai_analysis_prefix: "üéØ",
      ai_review_prefix: "üîç AI Kod ƒ∞ncelemesi:",
    },
    providers: {
      openai: "OpenAI",
      gemini: "Google Gemini",
      claude: "Anthropic Claude",
    },
  },
};

// Aktif dil √ßevirisini almak i√ßin helper fonksiyon
function getTranslations(): Translations {
  const config = vscode.workspace.getConfiguration("codeFeedback");
  const selectedLanguage = config.get("language", "english") as string;

  // Eƒüer se√ßilen dil mevcut deƒüilse, varsayƒ±lan olarak ƒ∞ngilizce kullan
  return translations[selectedLanguage] || translations.english;
}

// String interpolation i√ßin helper fonksiyon - deƒüi≈üken deƒüerleri template'e enjekte eder
function interpolateString(
  template: string,
  values: Record<string, any>
): string {
  return template.replace(/\{(\w+)\}/g, (match, key) => {
    return values[key]?.toString() || match;
  });
}

// Global deƒüi≈ükenler - kod bloƒüu se√ßimi i√ßin timer ekledim
let codeBlockSelectionTimer: NodeJS.Timeout | undefined;

// Temel veri yapƒ±larƒ± ve tipler
let feedbackPanel: vscode.WebviewPanel | undefined;
let cursorTimer: NodeJS.Timeout | undefined;
let feedbackList: Array<{
  message: string;
  type: "cursor" | "newline" | "ai" | "error" | "info";
  timestamp: string;
}> = [];
let lastAnalyzedContent: string = "";
let aiAnalysisTimer: NodeJS.Timeout | undefined;

// Enhanced AI configuration to support multiple providers
interface AIConfig {
  provider: AIProvider;
  openai: {
    apiKey: string;
    model: string;
  };
  gemini: {
    apiKey: string;
    model: string;
  };
  claude: {
    apiKey: string;
    model: string;
  };
  enabled: boolean;
}

// Generic AI response interface that works for all providers
interface AIResponse {
  content: string;
  usage?: {
    inputTokens?: number;
    outputTokens?: number;
    totalTokens?: number;
  };
}

// Hata t√ºrleri - her hata kategorisi farklƒ± kullanƒ±cƒ± deneyimi gerektirir
enum AIErrorType {
  AUTHENTICATION = "authentication",
  RATE_LIMIT = "rate_limit",
  NETWORK = "network",
  SERVICE_UNAVAILABLE = "service_unavailable",
  QUOTA_EXCEEDED = "quota_exceeded",
  PROVIDER_NOT_CONFIGURED = "provider_not_configured",
  UNKNOWN = "unknown",
}

// Detaylƒ± hata bilgisi yapƒ±sƒ±
interface AIError {
  type: AIErrorType;
  message: string;
  provider?: AIProvider;
  statusCode?: number;
  retryAfter?: number;
  canRetry: boolean;
}

// Global hata takip deƒüi≈ükenleri - kullanƒ±cƒ± deneyimini optimize etmek i√ßin
let lastErrorTime: number = 0;
let consecutiveErrors: number = 0;
let isAITemporarilyDisabled: boolean = false;

// Mevcut dilin g√∂r√ºnen adƒ±nƒ± al - kullanƒ±cƒ±ya g√∂stermek i√ßin
function getCurrentLanguageDisplayName(): string {
  const config = vscode.workspace.getConfiguration("codeFeedback");
  const selectedLanguage = config.get("language", "english") as string;

  const displayNames: Record<string, string> = {
    english: "English",
    espanol: "Espa√±ol",
    turkce: "T√ºrk√ße",
  };

  return displayNames[selectedLanguage] || "English";
}

// Extension'ƒ±n ana aktivasyon fonksiyonu
export function activate(context: vscode.ExtensionContext) {
  console.log("AI Code Feedback extension is now active!");

  // Configuration deƒüi≈üikliklerini dinle - kullanƒ±cƒ± ayarlarƒ± deƒüi≈ütirdiƒüinde tetiklenir
  const configChangeListener = vscode.workspace.onDidChangeConfiguration(
    (event) => {
      // Dil deƒüi≈üikliklerini kontrol et
      if (event.affectsConfiguration("codeFeedback.language")) {
        console.log("Language setting changed, updating interface...");
        updateFeedbackPanel();

        const t = getTranslations();
        addFeedback(
          `‚úÖ Language changed to: ${getCurrentLanguageDisplayName()}`,
          "info"
        );
      }

      // AI provider deƒüi≈üikliklerini kontrol et
      if (event.affectsConfiguration("codeFeedback.ai.provider")) {
        console.log("AI provider setting changed");
        const config = getAIConfig();
        const t = getTranslations();

        // Provider deƒüi≈üikliƒüini kullanƒ±cƒ±ya bildir
        addFeedback(
          interpolateString(t.notifications.provider_changed, {
            provider: t.providers[config.provider] || config.provider,
          }),
          "info"
        );

        // Eƒüer AI ge√ßici olarak devre dƒ±≈üƒ±ysa ve yeni provider d√ºzg√ºn yapƒ±landƒ±rƒ±lmƒ±≈üsa, tekrar etkinle≈ütir
        if (isProviderConfigured(config) && isAITemporarilyDisabled) {
          isAITemporarilyDisabled = false;
          consecutiveErrors = 0;
          addFeedback(
            "‚úÖ AI provider configured - AI features re-enabled!",
            "info"
          );
        }
      }

      // API key deƒüi≈üikliklerini kontrol et (t√ºm provider'lar i√ßin)
      if (
        event.affectsConfiguration("codeFeedback.openai.apiKey") ||
        event.affectsConfiguration("codeFeedback.gemini.apiKey") ||
        event.affectsConfiguration("codeFeedback.claude.apiKey")
      ) {
        console.log("API key setting changed");

        const config = getAIConfig();
        if (isProviderConfigured(config) && isAITemporarilyDisabled) {
          isAITemporarilyDisabled = false;
          consecutiveErrors = 0;
          const t = getTranslations();
          addFeedback("‚úÖ API key updated - AI features re-enabled!", "info");
        }
      }
    }
  );

  // Listener'ƒ± context'e ekle - extension kapanƒ±rken temizlensin
  context.subscriptions.push(configChangeListener);

  // Extension ayarlarƒ±nƒ± kaydet ve kontrol et
  registerConfiguration();

  // Feedback panelini olu≈ütur - kullanƒ±cƒ±nƒ±n feedback'leri g√∂receƒüi yer
  createFeedbackPanel(context);

  // ƒ∞mle√ß hareketi dinleyicisi - kullanƒ±cƒ± imleci bir yerde bƒ±raktƒ±ƒüƒ±nda tetiklenir
  const cursorListener = vscode.window.onDidChangeTextEditorSelection(
    (event) => {
      handleCursorMovement(event);
      handleCodeBlockSelection(event); // Yeni √∂zellik: Kod bloƒüu se√ßimi
    }
  );

  // Metin deƒüi≈üikliƒüi dinleyicisi - kod yazƒ±ldƒ±ƒüƒ±nda tetiklenir
  const textChangeListener = vscode.workspace.onDidChangeTextDocument(
    (event) => {
      handleTextChange(event);
      scheduleAIAnalysis(event);
    }
  );

  // Event listener'larƒ± context'e ekle - extension kapanƒ±rken otomatik temizlensin
  context.subscriptions.push(cursorListener, textChangeListener);
}

// Check if the selected provider is properly configured
function isProviderConfigured(config: AIConfig): boolean {
  switch (config.provider) {
    case AIProvider.OPENAI:
      return !!config.openai?.apiKey;
    case AIProvider.GEMINI:
      return !!config.gemini?.apiKey;
    case AIProvider.CLAUDE:
      return !!config.claude?.apiKey;
    default:
      return false;
  }
}

// Enhanced configuration registration to handle multiple providers
function registerConfiguration() {
  const config = vscode.workspace.getConfiguration("codeFeedback");
  const t = getTranslations();

  const aiConfig = getAIConfig();

  // Provider se√ßilmemi≈üse kullanƒ±cƒ±yƒ± bilgilendir
  if (!aiConfig.provider) {
    vscode.window
      .showInformationMessage(
        t.errors.provider_not_selected,
        t.actions.open_settings
      )
      .then((selection) => {
        if (selection === t.actions.open_settings) {
          vscode.commands.executeCommand(
            "workbench.action.openSettings",
            "codeFeedback.ai.provider"
          );
        }
      });

    addFeedback(t.errors.provider_not_selected, "error");
    return;
  }

  // Se√ßilen provider'ƒ±n yapƒ±landƒ±rƒ±lmƒ±≈ü olup olmadƒ±ƒüƒ±nƒ± kontrol et
  if (!isProviderConfigured(aiConfig)) {
    const providerName = t.providers[aiConfig.provider] || aiConfig.provider;

    // Provider'a g√∂re uygun action button'larƒ± belirle
    let getKeyAction = t.actions.get_api_key;
    let keyUrl = "";

    switch (aiConfig.provider) {
      case AIProvider.OPENAI:
        getKeyAction = t.actions.get_openai_key;
        keyUrl = "https://platform.openai.com/api-keys";
        break;
      case AIProvider.GEMINI:
        getKeyAction = t.actions.get_gemini_key;
        keyUrl = "https://makersuite.google.com/app/apikey";
        break;
      case AIProvider.CLAUDE:
        getKeyAction = t.actions.get_claude_key;
        keyUrl = "https://console.anthropic.com/dashboard";
        break;
    }

    vscode.window
      .showInformationMessage(
        `${t.notifications.api_key_setup_title} (${providerName})`,
        t.actions.open_settings,
        getKeyAction
      )
      .then((selection) => {
        if (selection === t.actions.open_settings) {
          vscode.commands.executeCommand(
            "workbench.action.openSettings",
            "codeFeedback"
          );
        } else if (selection === getKeyAction) {
          vscode.env.openExternal(vscode.Uri.parse(keyUrl));
        }
      });

    addFeedback(t.errors.api_key_configuration_needed, "error");
  }
}

// Feedback panelini olu≈ütur - kullanƒ±cƒ± aray√ºz√ºn√ºn merkezi
function createFeedbackPanel(context: vscode.ExtensionContext) {
  const t = getTranslations(); // √áeviri sistemini kullan

  feedbackPanel = vscode.window.createWebviewPanel(
    "aiFeedback",
    t.ui.panel_title,
    vscode.ViewColumn.Two,
    {
      enableScripts: true,
    }
  );

  // ƒ∞lk paneli g√ºncelle
  updateFeedbackPanel();
}

// Kod bloƒüu se√ßimi i≈üleyicisi - kullanƒ±cƒ± kod se√ßtiƒüinde tetiklenir
function handleCodeBlockSelection(
  event: vscode.TextEditorSelectionChangeEvent
) {
  // √ñnceki timer'ƒ± temizle - yeni se√ßim olduƒüu i√ßin
  if (codeBlockSelectionTimer) {
    clearTimeout(codeBlockSelectionTimer);
  }

  const editor = vscode.window.activeTextEditor;
  if (!editor) return;

  // Se√ßim kontrol√º - kullanƒ±cƒ±nƒ±n ger√ßekten kod se√ßip se√ßmediƒüini kontrol et
  const selection = editor.selection;

  // Eƒüer se√ßim yoksa veya tek karakter se√ßilmi≈üse, i≈ülem yapma
  if (
    selection.isEmpty ||
    (selection.start.line === selection.end.line &&
      selection.end.character - selection.start.character < 2)
  ) {
    return;
  }

  // Se√ßilen metni al
  const selectedText = editor.document.getText(selection).trim();

  // Eƒüer se√ßilen metin √ßok kƒ±sa ise (5 karakterden az) i≈ülem yapma
  if (selectedText.length < 5) {
    return;
  }

  // 2 saniye bekle - kullanƒ±cƒ± se√ßimini tamamlamasƒ± i√ßin
  codeBlockSelectionTimer = setTimeout(async () => {
    const t = getTranslations(); // √áeviri sistemini kullan

    // Kullanƒ±cƒ±ya se√ßim hakkƒ±nda bilgi ver
    addFeedback(
      `üìù Code block selected (${
        selection.end.line - selection.start.line + 1
      } lines) - Analyzing...`,
      "info"
    );

    // AI'dan kod bloƒüu analizi iste
    await requestAICodeBlockAnalysis(selectedText, selection, editor.document);
  }, 2000);
}

// ƒ∞mle√ß hareketi i≈üleyicisi - kullanƒ±cƒ± imleci belli bir yerde bƒ±raktƒ±ƒüƒ±nda tetiklenir
function handleCursorMovement(event: vscode.TextEditorSelectionChangeEvent) {
  // √ñnceki timer'ƒ± temizle - yeni hareket olduƒüu i√ßin
  if (cursorTimer) {
    clearTimeout(cursorTimer);
  }

  // 3 saniye sonra analiz yap - kullanƒ±cƒ± ger√ßekten o noktada duruyor demektir
  cursorTimer = setTimeout(async () => {
    const editor = vscode.window.activeTextEditor;
    if (editor) {
      const position = editor.selection.active;
      const lineText = editor.document.lineAt(position.line).text;

      // √ñnce temel context analizi yap - anƒ±nda feedback i√ßin
      const contextualMessage = analyzeCurrentContext(lineText, position);
      addFeedback(contextualMessage, "info");

      // Sonra AI'dan daha detaylƒ± analiz iste
      await requestAIContextAnalysis(lineText, position, editor.document);
    }
  }, 3000);
}

// Metin deƒüi≈üikliƒüi i≈üleyicisi - yeni satƒ±r ekleme gibi deƒüi≈üiklikleri yakalar
function handleTextChange(event: vscode.TextDocumentChangeEvent) {
  const t = getTranslations(); // √áeviri sistemini kullan

  // Her deƒüi≈üikliƒüi kontrol et ve kullanƒ±cƒ±ya pozitif feedback ver
  for (const change of event.contentChanges) {
    if (change.text.includes("\n")) {
      const lineCount = change.text.split("\n").length - 1;
      let message =
        lineCount === 1
          ? t.newline_messages.single
          : interpolateString(t.newline_messages.multiple, {
              count: lineCount,
            });
      addFeedback(message, "newline");
    }
  }
}

// AI analizi planla - kullanƒ±cƒ± kod yazmayƒ± bitirince tetiklensin
function scheduleAIAnalysis(event: vscode.TextDocumentChangeEvent) {
  // √ñnceki AI analiz timer'ƒ±nƒ± iptal et
  if (aiAnalysisTimer) {
    clearTimeout(aiAnalysisTimer);
  }

  // 5 saniye sonra AI analizi yap - kullanƒ±cƒ± yazmayƒ± bitirmi≈ü olabilir
  aiAnalysisTimer = setTimeout(async () => {
    await requestAICodeAnalysis(event.document);
  }, 5000);
}

// Enhanced AI configuration getter to support multiple providers
function getAIConfig(): AIConfig {
  const config = vscode.workspace.getConfiguration("codeFeedback");

  return {
    provider: config.get("ai.provider", AIProvider.OPENAI) as AIProvider,
    openai: {
      apiKey: config.get("openai.apiKey", ""),
      model: config.get("openai.model", "gpt-3.5-turbo"),
    },
    gemini: {
      apiKey: config.get("gemini.apiKey", ""),
      model: config.get("gemini.model", "gemini-1.5-flash"),
    },
    claude: {
      apiKey: config.get("claude.apiKey", ""),
      model: config.get("claude.model", "claude-3-5-haiku-20241022"),
    },
    enabled: config.get("ai.enabled", true),
  };
}

// Gelen hatalarƒ± kategorize et - her hata t√ºr√º farklƒ± muamele gerektirir
function categorizeAIError(
  error: any,
  response?: Response,
  provider?: AIProvider
): AIError {
  console.log(
    "Categorizing AI error:",
    error,
    response?.status,
    "Provider:",
    provider
  );

  // Network hatalarƒ±nƒ± yakala - internet baƒülantƒ±sƒ± veya DNS sorunlarƒ±
  if (
    error.name === "TypeError" &&
    (error.message.includes("fetch") || error.message.includes("network"))
  ) {
    return {
      type: AIErrorType.NETWORK,
      message: "No internet connection or AI service is unreachable",
      provider,
      canRetry: true,
    };
  }

  // HTTP response hatalarƒ±nƒ± analiz et
  if (response && !response.ok) {
    const statusCode = response.status;

    switch (statusCode) {
      case 401: // Unauthorized - yanlƒ±≈ü API anahtarƒ±
        return {
          type: AIErrorType.AUTHENTICATION,
          message: `Invalid ${provider} API key. Please check your configuration.`,
          provider,
          statusCode,
          canRetry: false,
        };

      case 429: // Too Many Requests - rate limit
        const retryAfter = response.headers.get("retry-after");
        return {
          type: AIErrorType.RATE_LIMIT,
          message: `${provider} API rate limit exceeded. Please wait before trying again.`,
          provider,
          statusCode,
          retryAfter: retryAfter ? parseInt(retryAfter) : 60,
          canRetry: true,
        };

      case 402: // Payment Required - quota a≈üƒ±mƒ±
        return {
          type: AIErrorType.QUOTA_EXCEEDED,
          message: `${provider} API quota exceeded. Please check your billing and usage.`,
          provider,
          statusCode,
          canRetry: false,
        };

      case 503: // Service Unavailable
      case 502: // Bad Gateway
      case 500: // Internal Server Error
        return {
          type: AIErrorType.SERVICE_UNAVAILABLE,
          message: `${provider} service is temporarily unavailable. Please try again later.`,
          provider,
          statusCode,
          canRetry: true,
        };
    }
  }

  // Bilinmeyen hatalar i√ßin fallback
  return {
    type: AIErrorType.UNKNOWN,
    message: `Unexpected error with ${provider}: ${
      error.message || "Unknown error occurred"
    }`,
    provider,
    canRetry: true,
  };
}

// Kullanƒ±cƒ±ya hata bildirimini g√∂ster - bu fonksiyon kullanƒ±cƒ± deneyiminin kalbini olu≈üturur
async function handleAIError(aiError: AIError): Promise<void> {
  console.log("Handling AI error:", aiError);
  const t = getTranslations(); // √áeviri sistemini kullan

  consecutiveErrors++;
  lastErrorTime = Date.now();

  // Feedback paneline hata durumunu hemen bildir - bu √ßok √∂nemli!
  const userFriendlyMessage = getUserFriendlyErrorMessage(aiError);
  addFeedback(`‚ùå ${userFriendlyMessage}`, "error");

  // √áok fazla ardƒ±≈üƒ±k hata varsa AI'ƒ± ge√ßici olarak devre dƒ±≈üƒ± bƒ±rak
  if (consecutiveErrors >= 3) {
    isAITemporarilyDisabled = true;

    vscode.window.showWarningMessage(t.notifications.too_many_errors_warning);
    addFeedback(t.errors.too_many_errors, "error");

    // 10 dakika sonra tekrar dene
    setTimeout(() => {
      isAITemporarilyDisabled = false;
      consecutiveErrors = 0;
      vscode.window.showInformationMessage(t.notifications.ai_re_enabled);
      addFeedback("‚úÖ AI features re-enabled and ready!", "info");
    }, 10 * 60 * 1000); // 10 dakika

    return; // Erken √ßƒ±k, daha fazla bildirim g√∂sterme
  }

  // Hata t√ºr√ºne g√∂re uygun bildirim g√∂ster - her hata farklƒ± yakla≈üƒ±m gerektirir
  switch (aiError.type) {
    case AIErrorType.AUTHENTICATION:
      const providerName = aiError.provider
        ? t.providers[aiError.provider]
        : "AI";
      let getKeyAction = t.actions.get_api_key;
      let keyUrl = "";
      let settingPath = "codeFeedback";

      // Provider'a g√∂re uygun action ve URL belirle
      switch (aiError.provider) {
        case AIProvider.OPENAI:
          getKeyAction = t.actions.get_openai_key;
          keyUrl = "https://platform.openai.com/api-keys";
          settingPath = "codeFeedback.openai.apiKey";
          break;
        case AIProvider.GEMINI:
          getKeyAction = t.actions.get_gemini_key;
          keyUrl = "https://makersuite.google.com/app/apikey";
          settingPath = "codeFeedback.gemini.apiKey";
          break;
        case AIProvider.CLAUDE:
          getKeyAction = t.actions.get_claude_key;
          keyUrl = "https://console.anthropic.com/dashboard";
          settingPath = "codeFeedback.claude.apiKey";
          break;
      }

      const authAction = await vscode.window.showErrorMessage(
        `${t.notifications.api_key_setup_title} (${providerName})`,
        t.actions.open_settings,
        getKeyAction,
        t.actions.disable_ai
      );

      if (authAction === t.actions.open_settings) {
        vscode.commands.executeCommand(
          "workbench.action.openSettings",
          settingPath
        );
      } else if (authAction === getKeyAction) {
        vscode.env.openExternal(vscode.Uri.parse(keyUrl));
      } else if (authAction === t.actions.disable_ai) {
        await vscode.workspace
          .getConfiguration("codeFeedback")
          .update("ai.enabled", false, vscode.ConfigurationTarget.Global);
        addFeedback("AI features disabled by user", "error");
      }
      break;

    case AIErrorType.RATE_LIMIT:
      const waitTime = aiError.retryAfter || 60;
      const minutes = Math.ceil(waitTime / 60);

      vscode.window.showWarningMessage(
        interpolateString(t.notifications.rate_limit_warning, { minutes })
      );

      // Rate limit s√ºresini bekle ve sonra tekrar etkinle≈ütir
      setTimeout(() => {
        consecutiveErrors = Math.max(0, consecutiveErrors - 1);
        addFeedback("‚úÖ Rate limit period passed - AI ready!", "info");
      }, waitTime * 1000);
      break;

    case AIErrorType.QUOTA_EXCEEDED:
      let billingUrl = "";
      switch (aiError.provider) {
        case AIProvider.OPENAI:
          billingUrl = "https://platform.openai.com/account/billing";
          break;
        case AIProvider.GEMINI:
          billingUrl = "https://console.cloud.google.com/billing";
          break;
        case AIProvider.CLAUDE:
          billingUrl = "https://console.anthropic.com/account/billing";
          break;
      }

      const quotaAction = await vscode.window.showErrorMessage(
        t.notifications.quota_exceeded_error,
        t.actions.check_billing,
        t.actions.disable_ai
      );

      if (quotaAction === t.actions.check_billing && billingUrl) {
        vscode.env.openExternal(vscode.Uri.parse(billingUrl));
      } else if (quotaAction === t.actions.disable_ai) {
        await vscode.workspace
          .getConfiguration("codeFeedback")
          .update("ai.enabled", false, vscode.ConfigurationTarget.Global);
        addFeedback("AI features disabled due to quota issues", "error");
      }
      break;

    case AIErrorType.NETWORK:
      if (consecutiveErrors === 1) {
        // ƒ∞lk network hatasƒ± i√ßin sadece feedback panelinde bildir
        vscode.window.showWarningMessage(t.notifications.network_warning);
      }
      break;

    case AIErrorType.SERVICE_UNAVAILABLE:
      vscode.window.showWarningMessage(
        t.notifications.service_unavailable_warning
      );
      break;

    default:
      if (consecutiveErrors <= 2) {
        // Bilinmeyen hatalar i√ßin sadece ilk birka√ß sefer bildirim g√∂ster
        vscode.window.showErrorMessage(
          `‚ùå AI Code Feedback: ${aiError.message}`
        );
      }
  }
}

// Kullanƒ±cƒ± dostu hata mesajƒ± olu≈ütur - karma≈üƒ±k teknik detaylarƒ± basitle≈ütir
function getUserFriendlyErrorMessage(error: AIError): string {
  const t = getTranslations(); // √áeviri sistemini kullan

  switch (error.type) {
    case AIErrorType.AUTHENTICATION:
      return t.errors.invalid_api_key;
    case AIErrorType.RATE_LIMIT:
      return t.errors.rate_limit_reached;
    case AIErrorType.QUOTA_EXCEEDED:
      return t.errors.quota_exceeded;
    case AIErrorType.NETWORK:
      return t.errors.connection_issue;
    case AIErrorType.SERVICE_UNAVAILABLE:
      return t.errors.service_unavailable;
    case AIErrorType.PROVIDER_NOT_CONFIGURED:
      return t.errors.provider_config_missing;
    default:
      return t.errors.ai_unavailable;
  }
}

// Enhanced system messages for different AI providers and languages
const aiSystemMessages: Record<string, Record<AIProvider, string>> = {
  english: {
    [AIProvider.OPENAI]: `You are an expert code mentor who provides brief, constructive feedback to help developers improve their coding skills. Always be encouraging and focus on learning opportunities. 

IMPORTANT: Respond in English with plain text only (no markdown formatting):
- Keep responses under 150 characters
- Use simple, clear language
- Be encouraging and educational
- No special formatting, bullet points, or code blocks`,

    [AIProvider.GEMINI]: `You are a helpful programming assistant providing brief, constructive code feedback. Be encouraging and educational.

IMPORTANT: Respond in English with plain text only:
- Maximum 150 characters
- Simple, clear language
- Encouraging and educational tone
- No markdown, formatting, or code blocks`,

    [AIProvider.CLAUDE]: `You are a knowledgeable code mentor providing brief, helpful feedback to developers. Focus on being encouraging and educational.

IMPORTANT: Respond in English with plain text only:
- Keep under 150 characters
- Use clear, simple language
- Be encouraging and educational
- No formatting, bullet points, or code blocks`,
  },

  espanol: {
    [AIProvider.OPENAI]: `Eres un mentor experto en programaci√≥n que proporciona retroalimentaci√≥n breve y constructiva para ayudar a los desarrolladores a mejorar sus habilidades de codificaci√≥n. Siempre s√© alentador y enf√≥cate en las oportunidades de aprendizaje.

IMPORTANTE: Responde en espa√±ol con texto plano solamente (sin formato markdown):
- Mant√©n las respuestas bajo 150 caracteres
- Usa lenguaje simple y claro
- S√© alentador y educativo
- Sin formato especial, vi√±etas o bloques de c√≥digo`,

    [AIProvider.GEMINI]: `Eres un asistente de programaci√≥n √∫til que proporciona retroalimentaci√≥n breve y constructiva sobre c√≥digo. S√© alentador y educativo.

IMPORTANTE: Responde en espa√±ol con texto plano solamente:
- M√°ximo 150 caracteres
- Lenguaje simple y claro
- Tono alentador y educativo
- Sin markdown, formato o bloques de c√≥digo`,

    [AIProvider.CLAUDE]: `Eres un mentor de c√≥digo conocedor que proporciona retroalimentaci√≥n breve y √∫til a los desarrolladores. Enf√≥cate en ser alentador y educativo.

IMPORTANTE: Responde en espa√±ol con texto plano solamente:
- Mant√©n bajo 150 caracteres
- Usa lenguaje claro y simple
- S√© alentador y educativo
- Sin formato, vi√±etas o bloques de c√≥digo`,
  },

  turkce: {
    [AIProvider.OPENAI]: `Geli≈ütiricilerin kodlama becerilerini geli≈ütirmelerine yardƒ±mcƒ± olmak i√ßin kƒ±sa, yapƒ±cƒ± geri bildirim saƒülayan uzman bir kod mentorsun. Her zaman cesaretlendirici ol ve √∂ƒürenme fƒ±rsatlarƒ±na odaklan.

√ñNEMLƒ∞: T√ºrk√ße yanƒ±t ver ve sadece d√ºz metin kullan (markdown formatƒ± yok):
- Yanƒ±tlarƒ± 150 karakter altƒ±nda tut
- A√ßƒ±k ve basit dil kullan
- Te≈üvik edici ve eƒüitici ol
- √ñzel format, madde i≈üareti veya kod bloƒüu yok`,

    [AIProvider.GEMINI]: `Kod hakkƒ±nda kƒ±sa, yapƒ±cƒ± geri bildirim saƒülayan yardƒ±mcƒ± bir programlama asistanƒ±sƒ±n. Cesaretlendirici ve eƒüitici ol.

√ñNEMLƒ∞: T√ºrk√ße yanƒ±t ver ve sadece d√ºz metin kullan:
- Maksimum 150 karakter
- Basit, a√ßƒ±k dil
- Cesaretlendirici ve eƒüitici ton
- Markdown, format veya kod bloƒüu yok`,

    [AIProvider.CLAUDE]: `Geli≈ütiricilere kƒ±sa, faydalƒ± geri bildirim saƒülayan bilgili bir kod mentorsun. Cesaretlendirici ve eƒüitici olmaya odaklan.

√ñNEMLƒ∞: T√ºrk√ße yanƒ±t ver ve sadece d√ºz metin kullan:
- 150 karakter altƒ±nda tut
- A√ßƒ±k, basit dil kullan
- Cesaretlendirici ve eƒüitici ol
- Format, madde i≈üareti veya kod bloƒüu yok`,
  },
};

function getLanguageSpecificPromptSuffix(): string {
  const config = vscode.workspace.getConfiguration("codeFeedback");
  const selectedLanguage = config.get("language", "english") as string;

  const suffixes: Record<string, string> = {
    english: `

Please provide your response in English using simple language. Keep it under 150 characters. Use plain text only, no formatting.`,

    espanol: `

Por favor proporciona tu respuesta en espa√±ol usando lenguaje simple. Mant√©nla bajo 150 caracteres. Solo texto plano, sin formato.`,

    turkce: `

L√ºtfen yanƒ±tƒ±nƒ± T√ºrk√ße olarak basit dil kullanarak ver. 150 karakter altƒ±nda tut. Sadece d√ºz metin, format yok.`,
  };

  return suffixes[selectedLanguage] || suffixes.english;
}

// Enhanced AI calling function that routes to appropriate provider
async function callAI(
  prompt: string,
  config: AIConfig
): Promise<string | null> {
  if (isAITemporarilyDisabled || !config.enabled) {
    return null;
  }

  if (!isProviderConfigured(config)) {
    const t = getTranslations();
    const aiError: AIError = {
      type: AIErrorType.PROVIDER_NOT_CONFIGURED,
      message: t.errors.provider_config_missing,
      provider: config.provider,
      canRetry: false,
    };
    await handleAIError(aiError);
    return null;
  }

  try {
    console.log(`Making ${config.provider} API call...`);

    let response: AIResponse | null = null;

    switch (config.provider) {
      case AIProvider.OPENAI:
        response = await callOpenAI(prompt, config);
        break;
      case AIProvider.GEMINI:
        response = await callGemini(prompt, config);
        break;
      case AIProvider.CLAUDE:
        response = await callClaude(prompt, config);
        break;
      default:
        throw new Error(`Unsupported AI provider: ${config.provider}`);
    }

    if (response) {
      consecutiveErrors = 0;
      return response.content;
    }

    return null;
  } catch (error) {
    console.error(`${config.provider} API call failed:`, error);
    const aiError = categorizeAIError(error, undefined, config.provider);
    await handleAIError(aiError);
    return null;
  }
}

// OpenAI API caller
async function callOpenAI(
  prompt: string,
  config: AIConfig
): Promise<AIResponse | null> {
  const selectedLanguage = vscode.workspace
    .getConfiguration("codeFeedback")
    .get("language", "english") as string;
  const systemMessage =
    aiSystemMessages[selectedLanguage]?.[AIProvider.OPENAI] ||
    aiSystemMessages.english[AIProvider.OPENAI];

  const response = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${config.openai.apiKey}`,
    },
    body: JSON.stringify({
      model: config.openai.model,
      messages: [
        {
          role: "system",
          content: systemMessage,
        },
        {
          role: "user",
          content: prompt,
        },
      ],
      max_tokens: 150,
      temperature: 0.7,
    }),
  });

  if (!response.ok) {
    const aiError = categorizeAIError(
      new Error(`HTTP ${response.status}`),
      response,
      AIProvider.OPENAI
    );
    await handleAIError(aiError);
    return null;
  }

  const data = (await response.json()) as OpenAIResponse;
  const content = data.choices[0]?.message?.content?.trim();

  return content
    ? {
        content,
        usage: {
          inputTokens: data.usage?.prompt_tokens,
          outputTokens: data.usage?.completion_tokens,
          totalTokens: data.usage?.total_tokens,
        },
      }
    : null;
}

// Google Gemini API caller
async function callGemini(
  prompt: string,
  config: AIConfig
): Promise<AIResponse | null> {
  const selectedLanguage = vscode.workspace
    .getConfiguration("codeFeedback")
    .get("language", "english") as string;
  const systemMessage =
    aiSystemMessages[selectedLanguage]?.[AIProvider.GEMINI] ||
    aiSystemMessages.english[AIProvider.GEMINI];

  const response = await fetch(
    `https://generativelanguage.googleapis.com/v1beta/models/${config.gemini.model}:generateContent?key=${config.gemini.apiKey}`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        contents: [
          {
            parts: [
              {
                text: `${systemMessage}\n\nUser: ${prompt}`,
              },
            ],
          },
        ],
        generationConfig: {
          maxOutputTokens: 150,
          temperature: 0.7,
        },
      }),
    }
  );

  if (!response.ok) {
    const aiError = categorizeAIError(
      new Error(`HTTP ${response.status}`),
      response,
      AIProvider.GEMINI
    );
    await handleAIError(aiError);
    return null;
  }

  const data = (await response.json()) as GeminiResponse;
  const content = data.candidates?.[0]?.content?.parts?.[0]?.text?.trim();

  return content
    ? {
        content,
        usage: {
          inputTokens: data.usageMetadata?.promptTokenCount,
          outputTokens: data.usageMetadata?.candidatesTokenCount,
          totalTokens: data.usageMetadata?.totalTokenCount,
        },
      }
    : null;
}

// Anthropic Claude API caller
async function callClaude(
  prompt: string,
  config: AIConfig
): Promise<AIResponse | null> {
  const selectedLanguage = vscode.workspace
    .getConfiguration("codeFeedback")
    .get("language", "english") as string;
  const systemMessage =
    aiSystemMessages[selectedLanguage]?.[AIProvider.CLAUDE] ||
    aiSystemMessages.english[AIProvider.CLAUDE];

  const response = await fetch("https://api.anthropic.com/v1/messages", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-api-key": config.claude.apiKey,
      "anthropic-version": "2023-06-01",
    },
    body: JSON.stringify({
      model: config.claude.model,
      max_tokens: 150,
      system: systemMessage,
      messages: [
        {
          role: "user",
          content: prompt,
        },
      ],
    }),
  });

  if (!response.ok) {
    const aiError = categorizeAIError(
      new Error(`HTTP ${response.status}`),
      response,
      AIProvider.CLAUDE
    );
    await handleAIError(aiError);
    return null;
  }

  const data = (await response.json()) as ClaudeResponse;
  const content = data.content?.[0]?.text?.trim();

  return content
    ? {
        content,
        usage: {
          inputTokens: data.usage?.input_tokens,
          outputTokens: data.usage?.output_tokens,
        },
      }
    : null;
}

async function requestAICodeBlockAnalysis(
  selectedCode: string,
  selection: vscode.Selection,
  document: vscode.TextDocument
) {
  const config = getAIConfig();
  const t = getTranslations();

  if (!config.enabled || isAITemporarilyDisabled) {
    return;
  }

  if (!isProviderConfigured(config)) {
    addFeedback(`‚ö†Ô∏è ${t.errors.provider_config_missing}`, "error");
    return;
  }

  try {
    const contextBefore = getContextAroundSelection(
      document,
      selection,
      "before"
    );
    const contextAfter = getContextAroundSelection(
      document,
      selection,
      "after"
    );
    const blockType = identifyCodeBlockType(selectedCode, document.languageId);
    const languageSuffix = getLanguageSpecificPromptSuffix();

    const prompt = `You are a programming teacher helping a student. The student selected this ${document.languageId} code block:

${selectedCode}

Block type: ${blockType}

Give brief feedback about this code block. Focus on:
1. Any syntax errors
2. Logic issues
3. One improvement suggestion

Keep response under 150 characters, plain text only.${languageSuffix}`;

    const aiResponse = await callAI(prompt, config);
    if (aiResponse) {
      addFeedback(`üîç Code Block: ${aiResponse}`, "ai");
    }
  } catch (error) {
    console.error("AI code block analysis error:", error);
  }
}

// G√ºncellenen AI context analizi fonksiyonu - √ßok dilli destek ile
async function requestAIContextAnalysis(
  lineText: string,
  position: vscode.Position,
  document: vscode.TextDocument
) {
  const config = getAIConfig();
  const t = getTranslations();

  if (!config.enabled || isAITemporarilyDisabled) {
    return;
  }

  if (!isProviderConfigured(config)) {
    addFeedback(`‚ö†Ô∏è ${t.errors.provider_config_missing}`, "error");
    return;
  }

  try {
    const context = gatherCodeContext(document, position);
    const languageSuffix = getLanguageSpecificPromptSuffix();

    const prompt = `You are a programming teacher. The student's cursor is at this line: "${lineText}"

Context:
${context}

Check for syntax errors or give one brief improvement tip. Keep response under 150 characters, plain text only.${languageSuffix}`;

    const aiResponse = await callAI(prompt, config);
    if (aiResponse) {
      addFeedback(`${t.ui.ai_analysis_prefix} ${aiResponse}`, "ai");
    }
  } catch (error) {
    console.error("AI context analysis error:", error);
  }
}

// G√ºncellenen AI kod analizi fonksiyonu
async function requestAICodeAnalysis(document: vscode.TextDocument) {
  const config = getAIConfig();
  const t = getTranslations();

  if (!config.enabled || isAITemporarilyDisabled) {
    return;
  }

  if (!isProviderConfigured(config)) {
    return;
  }

  try {
    const codeSnippet = document.getText();
    const maxLength = 2000;
    const analysisCode =
      codeSnippet.length > maxLength
        ? codeSnippet.substring(0, maxLength) + "\n// ... (truncated)"
        : codeSnippet;

    const languageSuffix = getLanguageSpecificPromptSuffix();

    const prompt = `You are a programming teacher reviewing a student's ${document.languageId} code:

${analysisCode}

Give brief feedback focusing on:
1. Main syntax errors
2. One improvement suggestion

Keep response under 150 characters, plain text only.${languageSuffix}`;

    const aiResponse = await callAI(prompt, config);
    if (aiResponse) {
      addFeedback(`${t.ui.ai_review_prefix} ${aiResponse}`, "ai");
    }
  } catch (error) {
    console.error("AI code analysis error:", error);
  }
}

// Mevcut context'i analiz et - AI olmadan da √ßalƒ±≈üan temel analiz
function analyzeCurrentContext(
  lineText: string,
  position: vscode.Position
): string {
  const t = getTranslations(); // √áeviri sistemini kullan
  const trimmedLine = lineText.trim();

  // Farklƒ± kod yapƒ±larƒ± i√ßin context-aware mesajlar
  if (trimmedLine.startsWith("function") || trimmedLine.includes("=>")) {
    return t.cursor_analysis.function;
  } else if (trimmedLine.includes("if") || trimmedLine.includes("else")) {
    return t.cursor_analysis.conditional;
  } else if (trimmedLine.includes("for") || trimmedLine.includes("while")) {
    return t.cursor_analysis.loop;
  } else if (trimmedLine.includes("//") || trimmedLine.includes("/*")) {
    return t.cursor_analysis.comment;
  } else if (trimmedLine.length > 100) {
    return interpolateString(t.cursor_analysis.long_line, {
      length: trimmedLine.length,
    });
  } else if (trimmedLine === "") {
    return t.cursor_analysis.empty_line;
  }

  const context =
    trimmedLine.length > 50
      ? trimmedLine.substring(0, 50) + "..."
      : trimmedLine;
  return interpolateString(t.cursor_analysis.generic, { context });
}

// Kod context'ini topla - AI'ya g√∂nderilecek kod par√ßasƒ±nƒ± hazƒ±rla
function gatherCodeContext(
  document: vscode.TextDocument,
  position: vscode.Position
): string {
  // ƒ∞mlecin etrafƒ±ndaki birka√ß satƒ±rƒ± al - context saƒülamak i√ßin
  const startLine = Math.max(0, position.line - 3);
  const endLine = Math.min(document.lineCount - 1, position.line + 3);

  let context = "";
  for (let i = startLine; i <= endLine; i++) {
    const lineText = document.lineAt(i).text;
    const marker = i === position.line ? " -> " : "    "; // Mevcut satƒ±rƒ± i≈üaretle
    context += `${marker}${lineText}\n`;
  }

  return context;
}

// Kod bloƒüu se√ßimi i√ßin yardƒ±mcƒ± fonksiyonlar
function getContextAroundSelection(
  document: vscode.TextDocument,
  selection: vscode.Selection,
  direction: "before" | "after"
): string {
  const maxLines = 3;
  let context = "";

  if (direction === "before") {
    const startLine = Math.max(0, selection.start.line - maxLines);
    for (let i = startLine; i < selection.start.line; i++) {
      context += document.lineAt(i).text + "\n";
    }
  } else {
    const endLine = Math.min(
      document.lineCount - 1,
      selection.end.line + maxLines
    );
    for (let i = selection.end.line + 1; i <= endLine; i++) {
      context += document.lineAt(i).text + "\n";
    }
  }

  return context.trim();
}

function identifyCodeBlockType(code: string, languageId: string): string {
  const trimmedCode = code.trim().toLowerCase();

  // Temel kod bloƒüu t√ºrlerini belirle
  if (trimmedCode.includes("function") || trimmedCode.includes("def ")) {
    return "Function Definition";
  } else if (trimmedCode.includes("if ") || trimmedCode.includes("else")) {
    return "Conditional Statement";
  } else if (trimmedCode.includes("for ") || trimmedCode.includes("while ")) {
    return "Loop Structure";
  } else if (trimmedCode.includes("class ")) {
    return "Class Definition";
  } else if (trimmedCode.includes("try ") || trimmedCode.includes("catch")) {
    return "Error Handling Block";
  } else if (trimmedCode.includes("{") && trimmedCode.includes("}")) {
    return "Code Block";
  } else {
    return "Code Fragment";
  }
}

// Feedback ekle - t√ºm feedback'ler burada toplanƒ±r
function addFeedback(
  message: string,
  type: "cursor" | "newline" | "ai" | "error" | "info"
) {
  const timestamp = new Date().toLocaleTimeString();
  feedbackList.push({ message, type, timestamp });

  // Performans i√ßin feedback listesini sƒ±nƒ±rla
  if (feedbackList.length > 50) {
    feedbackList = feedbackList.slice(-50);
  }

  updateFeedbackPanel();
}

// G√ºncellenen updateFeedbackPanel fonksiyonu - multi-provider support ile
function updateFeedbackPanel() {
  if (feedbackPanel) {
    const t = getTranslations();
    const config = getAIConfig();
    const currentProvider = t.providers[config.provider] || config.provider;

    const feedbackHtml = feedbackList
      .map((feedback) => {
        const typeClass = `feedback-${feedback.type}`;
        const typeIcon = getTypeIcon(feedback.type);
        return `<div class="feedback-item ${typeClass}">
                    <span class="feedback-icon">${typeIcon}</span>
                    <span class="feedback-content">${feedback.message}</span>
                    <span class="feedback-time">${feedback.timestamp}</span>
                </div>`;
      })
      .join("");

    feedbackPanel.webview.html = `
            <!DOCTYPE html>
            <html>
            <head>
                <title>AI Feedback</title>
                <style>
                    body { 
                        font-family: var(--vscode-font-family);
                        font-size: var(--vscode-font-size);
                        background-color: var(--vscode-editor-background);
                        color: var(--vscode-editor-foreground);
                        padding: 20px;
                        margin: 0;
                        line-height: 1.6;
                        height: 100vh;
                        overflow-y: auto;
                        scroll-behavior: smooth;
                    }
                    
                    .feedback-item { 
                        margin: 8px 0; 
                        padding: 12px 16px; 
                        background-color: var(--vscode-textBlockQuote-background);
                        border: 1px solid var(--vscode-widget-border);
                        border-radius: 6px;
                        display: flex;
                        align-items: flex-start;
                        gap: 12px;
                    }
                    
                    .feedback-cursor {
                        border-left: 3px solid var(--vscode-charts-blue);
                    }
                    
                    .feedback-newline {
                        border-left: 3px solid var(--vscode-charts-green);
                    }
                    
                    .feedback-ai {
						border-left: 3px solid var(--vscode-charts-purple);
						background-color: var(--vscode-inputValidation-infoBackground);
					}

					.feedback-info {
						border-left: 3px solid var(--vscode-charts-blue);
						background-color: var(--vscode-textBlockQuote-background);
					}
                    
                    .feedback-error {
                        border-left: 3px solid var(--vscode-charts-red);
                        background-color: var(--vscode-inputValidation-errorBackground);
                    }
                    
                    .feedback-icon {
                        font-size: 14px;
                        width: 20px;
                        text-align: center;
                        flex-shrink: 0;
                        margin-top: 2px;
                    }
                    
                    .feedback-content {
                        flex: 1;
                        font-size: 13px;
                        word-wrap: break-word;
                        overflow-wrap: break-word;
                    }
                    
                    .feedback-time {
                        font-size: 11px;
                        color: var(--vscode-descriptionForeground);
                        flex-shrink: 0;
                        margin-top: 2px;
                    }
                    
                    .feedback-ai .feedback-time {
                        color: var(--vscode-button-secondaryForeground);
                    }
                    
                    .feedback-item:hover {
                        background-color: var(--vscode-list-hoverBackground);
                    }
                    
                    .feedback-ai:hover {
                        background-color: var(--vscode-button-hoverBackground) !important;
                    }
                    
                    .feedback-container {
                        min-height: calc(100vh - 140px);
                        display: flex;
                        flex-direction: column;
                        justify-content: flex-start;
                    }
                    
                    .panel-title {
                        color: var(--vscode-titleBar-activeForeground);
                        border-bottom: 1px solid var(--vscode-widget-border);
                        padding-bottom: 10px;
                        margin-bottom: 20px;
                        font-size: 16px;
                        font-weight: bold;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    }
                    
                    .provider-info {
                        font-size: 12px;
                        color: var(--vscode-descriptionForeground);
                        font-weight: normal;
                        background: var(--vscode-badge-background);
                        color: var(--vscode-badge-foreground);
                        padding: 2px 8px;
                        border-radius: 12px;
                    }
                </style>
            </head>
            <body>
                <div class="panel-title">
                    <span>${t.ui.panel_title}</span>
                    <span class="provider-info">${currentProvider}</span>
                </div>
                <div class="feedback-container" id="feedbackContainer">${feedbackHtml}</div>
                
                <script>
                    function scrollToBottom() {
                        setTimeout(() => {
                            window.scrollTo({
                                top: document.body.scrollHeight,
                                behavior: 'smooth'
                            });
                        }, 100);
                    }
                    
                    document.addEventListener('DOMContentLoaded', scrollToBottom);
                    window.addEventListener('load', scrollToBottom);
                    scrollToBottom();
                </script>
            </body>
            </html>
        `;
  }
}

function getTypeIcon(
  type: "cursor" | "newline" | "ai" | "error" | "info"
): string {
  switch (type) {
    case "cursor":
      return "üëÜ";
    case "info":
      return "üëÜ";
    case "newline":
      return "‚Üµ";
    case "ai":
      return "ü§ñ";
    case "error":
      return "‚ö†Ô∏è";
    default:
      return "üí°";
  }
}

export function deactivate() {
  if (cursorTimer) {
    clearTimeout(cursorTimer);
  }
  if (aiAnalysisTimer) {
    clearTimeout(aiAnalysisTimer);
  }
  if (codeBlockSelectionTimer) {
    clearTimeout(codeBlockSelectionTimer);
  }
}
